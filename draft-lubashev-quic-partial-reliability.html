<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Partially Reliable Streams for QUIC</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 550px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 55px;
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc, #rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>ul.toc {
    top: 140px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 16px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 36px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 18px;
  line-height: 27px%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Notational Conventions">
<link href="#rfc.section.2" rel="Chapter" title="2 Introduction">
<link href="#rfc.section.3" rel="Chapter" title="3 Partially Reliable Streams">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Min Stream Offset">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 MIN_STREAM_DATA Frame">
<link href="#rfc.section.4" rel="Chapter" title="4 Effect of MIN_STREAM_DATA on Flow Control">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Sender Flow Control">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Receiver Flow Control">
<link href="#rfc.section.5" rel="Chapter" title="5 Sender Interface and Behavior">
<link href="#rfc.section.6" rel="Chapter" title="6 Receiver Interface and Behavior">
<link href="#rfc.section.7" rel="Chapter" title="7 Retransmission of MIN_STREAM_DATA">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations">
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgments">
<link href="#rfc.references" rel="Chapter" title="11 Normative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.8.3 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Lubashev, I." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-lubashev-quic-partial-reliability-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-1-20" />
  <meta name="dct.abstract" content="This memo introduces a MIN_STREAM_DATA frame to enable partial reliability for QUIC streams.  The MIN_STREAM_DATA frame allows a sender to give up on retransmitting older parts of a stream and to notify the receiver about this decision. The content of this draft is intended for merging into QUIC transport, recovery, and applicability drafts." />
  <meta name="description" content="This memo introduces a MIN_STREAM_DATA frame to enable partial reliability for QUIC streams.  The MIN_STREAM_DATA frame allows a sender to give up on retransmitting older parts of a stream and to notify the receiver about this decision. The content of this draft is intended for merging into QUIC transport, recovery, and applicability drafts." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">QUIC</td>
<td class="right">I. Lubashev</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Akamai Technologies</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">January 20, 2018</td>
</tr>
<tr>
<td class="left">Expires: July 24, 2018</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Partially Reliable Streams for QUIC<br />
  <span class="filename">draft-lubashev-quic-partial-reliability-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This memo introduces a MIN_STREAM_DATA frame to enable partial reliability for QUIC streams.  The MIN_STREAM_DATA frame allows a sender to give up on retransmitting older parts of a stream and to notify the receiver about this decision. The content of this draft is intended for merging into QUIC transport, recovery, and applicability drafts.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on July 24, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Notational Conventions</a>
</li>
<li>2.   <a href="#rfc.section.2">Introduction</a>
</li>
<li>3.   <a href="#rfc.section.3">Partially Reliable Streams</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Min Stream Offset</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">MIN_STREAM_DATA Frame</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Effect of MIN_STREAM_DATA on Flow Control</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Sender Flow Control</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Receiver Flow Control</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Sender Interface and Behavior</a>
</li>
<li>6.   <a href="#rfc.section.6">Receiver Interface and Behavior</a>
</li>
<li>7.   <a href="#rfc.section.7">Retransmission of MIN_STREAM_DATA</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a>
</li>
<li>10.   <a href="#rfc.section.10">Acknowledgments</a>
</li>
<li>11.   <a href="#rfc.references">Normative References</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#conventions" id="conventions">Notational Conventions</a>
</h1>
<p id="rfc.section.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.2.p.1">Some applications, especially applications with real-time requirements, need a partially reliable transport.  These applications typically communicate data in application-specific messages that are serialized over QUIC streams.  Applications desire partially reliable transport, when their messages expire and lose their usefulness due to later events (time passing, newer messages, etc).</p>
<p id="rfc.section.2.p.2">The content of this draft is intended for <a href="#I-D.ietf-quic-transport" class="xref">[I-D.ietf-quic-transport]</a>, <a href="#I-D.ietf-quic-recovery" class="xref">[I-D.ietf-quic-recovery]</a> and, <a href="#I-D.ietf-quic-applicability" class="xref">[I-D.ietf-quic-applicability]</a>.</p>
<p id="rfc.section.2.p.3">The key to partial reliability is notifying the peer about data that will not be retransmitted and managing flow control for the connection.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#partially-reliable-streams" id="partially-reliable-streams">Partially Reliable Streams</a>
</h1>
<p id="rfc.section.3.p.1">It is possible to provide partial reliability without any changes to QUIC transport by using QUIC streams, encoding one message per QUIC stream.  When the message expires, the sender can reset the stream, causing RST_STREAM frame to be transmitted, unless all data in the stream has already been fully acknowledged.  The problem with this approach is that messages transmitted by the application typically belong to a message stream, and applications may need to support multiple concurrent message streams.  Hence, a message-per-stream approach requires each message to contain an extra header portion to associate the message with a logical application stream.  In case of short messages, this approach introduces a significant overhead due to STREAM frames and message headers. It also places the burden on the application to reorder data arriving on multiple QUIC streams.  Furthermore, splitting each application stream into multiple QUIC streams renders QUIC per-stream flow control ineffective and requires an application to build its own.</p>
<p id="rfc.section.3.p.2">An alternative is the proposed single-stream mechanism that keeps messages arriving in order on a single stream.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#min-stream-offset" id="min-stream-offset">Min Stream Offset</a>
</h1>
<p id="rfc.section.3.1.p.1">This proposal introduces a new QUIC stream variable &#8220;Min Stream Offset&#8221; that indicates the smallest retransmittable data offset.  The receiver SHOULD NOT wait for any data at offsets smaller than Min Stream Offset to be retransmitted by the sender.  Initially, Min Stream Offset is 0 for all streams.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#min_stream_data" id="min_stream_data">MIN_STREAM_DATA Frame</a>
</h1>
<p id="rfc.section.3.2.p.1">The MIN_STREAM_DATA frame (types 0x?? (type) and 0x?? (type+1)) is used in flow control to inform the peer of the minimum (re-)transmittable data offset on a stream.  If the least significant bit is set, Unsent Bytes field is present in the frame.</p>
<p id="rfc.section.3.2.p.2">The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sent Data (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Unsent Bytes (i)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.3.2.p.3">The fields in the MIN_STREAM_DATA frame are as follows:</p>
<p></p>

<dl>
<dt>Stream ID:</dt>
<dd style="margin-left: 8">The stream ID of the stream that is affected encoded as a variable-length integer.</dd>
<dt>Sent Data:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the number of data octets written to the stream (since the beginning of the stream) that have expired and will not be retransmitted.</dd>
<dt>Unsent Bytes:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the number of data octets past Sent Data that have expired but have never been sent and will not be transmitted.  If Unsent Bytes field is absent, it is presumed to be 0.</dd>
</dl>
<p id="rfc.section.3.2.p.5">Since Stream 0 MUST be reliable, Stream ID MUST NOT be 0.  If Unsent Bytes field is present in the frame, it MUST NOT be 0 (reserved for the future use).</p>
<p id="rfc.section.3.2.p.6">If Unsent Bytes field is present in the frame, it implies that all data previously sent to the receiver on the stream has expired.  Hence, Sent Data is implicitly the Largest Sent Data on the stream.</p>
<p id="rfc.section.3.2.p.7">Min Stream Offset (<a href="#min-stream-offset" class="xref">Section 3.1</a>) for Stream ID is determined by the formula:</p>
<pre>
  Min Stream Offset = Sent Data + Unsent Bytes
</pre>
<p id="rfc.section.3.2.p.8">The Min Stream Offset for a stream MUST NOT be reduced by the sender in a subsequent MIN_STREAM_DATA frame, but loss and reordering can cause MIN_STREAM_DATA frames to be received out of order.  MIN_STREAM_DATA frames that do not increase the stream&#8217;s Min Stream Offset MUST be ignored.</p>
<p id="rfc.section.3.2.p.9">The sender MUST NOT send a STREAM frame with an Offset smaller then Min Stream Offset for the stream.</p>
<p id="rfc.section.3.2.p.10">The value of the Largest Received Offset of the stream is immediately advanced upon receipt, if it is smaller than Sent Data.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#flow-control" id="flow-control">Effect of MIN_STREAM_DATA on Flow Control</a>
</h1>
<p id="rfc.section.4.p.1">Specifying Unsent Bytes separately from Send Data in MIN_STREAM_DATA frame avoids consuming stream and connection flow control credits for Unsent Bytes. Flow control credits protect receiver buffers, but Unsent Bytes correspond to bytes that will not need buffering. A sender that desires to expire a large number of bytes that have never been transmitted can do so in a single frame and without closing down the connection flow control window, because Unsent Bytes do not require flow control credits.</p>
<p id="rfc.section.4.p.2">Flow control accounting is the most complex part of the proposal.  The flow control has two goals:</p>
<p></p>

<ol>
<li>Allow the sender to notify the receiver about Unsent Bytes past Sent Data, requesting that the receiver advance its stream and connection flow control windows to accommodate skipping Unsent Bytes. That needs to be done without blocking the rest of the streams for an rtt (until the sender receives a corresponding MAX_DATA frame).</li>
<li>Ensure that the connection flow control credits designated for skipping Unsent Bytes (that do not need buffering on the receiver) cannot be used to send stream data on other streams.</li>
</ol>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#flow-control-sender" id="flow-control-sender">Sender Flow Control</a>
</h1>
<p id="rfc.section.4.1.p.1">When an ACK frame is received for a packet containing a MIN_STREAM_OFFSET frame and the Current Sent Data of the stream is smaller than Min Stream Offset of the acknowledged MIN_STREAM_OFFSET frame, the Current Sent Data is advanced to the Min Stream Offset.  (Note that this can only happen, when Unsent Bytes is non-zero in the acknowledged MIN_STREAM_OFFSET frame.)</p>
<p id="rfc.section.4.1.p.2">If the Current Sent Data for at least one stream was advanced due to the receipt of a packet containing an ACK frame, and, after processing that entire packet, the sum of the Current Sent Data on all streams - including streams in terminal states but excluding stream 0 - exceeds MAX_DATA, the sender MUST terminate a connection with a QUIC_FLOW_CONTROL_SENT_TOO_MUCH_DATA error.</p>
<p id="rfc.section.4.1.p.3">It is possible that the Current Sent Data for at least one stream will be advanced past MAX_STREAM_DATA for that stream.  In that case, no data octets can be sent on that stream until a MAX_STREAM_DATA frame advancing the maximum offset is received.  Note that this does not prohibit using the Current Sent Data beyond MAX_STREAM_DATA in an RST_STREAM frame, a MIN_STREAM_DATA frame, or a STREAM frame with no data and FIN bit set.</p>
<p id="rfc.section.4.1.p.4">It is possible that Current Sent Data will be advanced due to an ACK frame on a closed stream, if it was closed via RST_STREAM.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#flow-control-receiver" id="flow-control-receiver">Receiver Flow Control</a>
</h1>
<p id="rfc.section.4.2.p.1">A stream whose Largest Received Offset smaller than the current Min Stream Offset is called a &#8220;Tail Gap&#8221; stream.</p>
<p id="rfc.section.4.2.p.2">When an ACK frame is sent acknowledging a packet containing a MIN_STREAM_DATA frame for a &#8220;Tail Gap&#8221; stream:</p>
<p></p>

<ul>
<li>The stream&#8217;s Largest Received Offset is saved as the stream&#8217;s &#8220;Last Sent Data&#8221;.  (It will be the Sent Data of the last processed MIN_STREAM_DATA frame for the stream.).</li>
<li>The stream&#8217;s Largest Received Offset MUST be advanced to Min Stream Offset, and MAX_DATA MUST be advanced by at least the same amount.</li>
<li>A stream whose Largest Received Offset was last updated due to this rule is called a &#8220;Gap-ACKed&#8221; stream.</li>
<li>A MIN_STREAM_DATA frame with Sent Data equal to Last Sent Data for a &#8220;Gap-ACKed&#8221; stream is called a &#8220;Gap-ACKed&#8221; MIN_STREAM_DATA frame.  (There can be multiple &#8220;Gap-ACKed&#8221; MIN_STREAM_DATA frames for a &#8220;Gap-ACKed&#8221; stream in case MIN_STREAM_DATA frame was received multiple times with the same Sent Data.)</li>
<li>A packet containing a &#8220;Gap-ACKed&#8221; MIN_STREAM_DATA frame is called a &#8220;Gap-ACKed&#8221; packet, unless an acknowledgment of that packet has been acknowledged by the sender.</li>
</ul>
<p id="rfc.section.4.2.p.4">A MAX_DATA frame MUST be sent in the same packet as an ACK frame acknowledging a &#8220;Gap-ACKed&#8221; packet.</p>
<p id="rfc.section.4.2.p.5">If a MAX_DATA frame is sent, the same packet MUST contain ACK frames acknowledging all &#8220;Gap-ACKed&#8221; packets.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#sender" id="sender">Sender Interface and Behavior</a>
</h1>
<p id="rfc.section.5.p.1">It is recommended that a QUIC library API provides a way for a sender to update the minimum retransmittable offset for a stream.  A typical sender would call this API function whenever data previously enqueued for transmission expires, per application semantics.  The sender would keep track of the message boundaries and request expiration of data on a message boundary.</p>
<p id="rfc.section.5.p.2">If all data between the current Min Stream Offset and the new Min Stream Offset has been acknowledged, no action is performed by the sender&#8217;s QUIC transport.  Otherwise, if there is unacknowledged data, a MIN_STREAM_DATA frame is transmitted.</p>
<p id="rfc.section.5.p.3">An application may decide to conditionally expire messages based on the delivery status of prior messages.  For example, an application may wish to ensure that its large messages are delivered at least at a given minimum rate before expiring a partially-delivered message just because there is a newer message to deliver.  That is, if the rate of data the application wishes to write exceeds the network&#8217;s throughput, the application may want to ensure that at least some messages are delivered in their entirety.  To support this use case, it is recommended that a QUIC library API provides a way for the sender to monitor the smallest unacknowledged stream offset greater than Min Stream Offset (<a href="#min-stream-offset" class="xref">Section 3.1</a>).</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#receiver" id="receiver">Receiver Interface and Behavior</a>
</h1>
<p id="rfc.section.6.p.1">The receiver SHOULD assume that none of the data up to Min Stream Offset (<a href="#min-stream-offset" class="xref">Section 3.1</a>) will be retransmitted.</p>
<p id="rfc.section.6.p.2">It is recommended that a QUIC library API provides a way for a receiver application to obtain the length of a gap corresponding to the expired data in addition to data octets that follow the gap.</p>
<p id="rfc.section.6.p.3">A receiver MAY discard any stream data received for an offset smaller than Min Stream Offset.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#retransmission" id="retransmission">Retransmission of MIN_STREAM_DATA</a>
</h1>
<p id="rfc.section.7.p.1">The most recent MIN_STREAM_DATA frame for a stream MUST be retransmitted until the sender is certain that the receiver is not expecting retransmission of any expired data.  I.e. the frame MUST be retransmitted until either the stream enters &#8220;half-closed (local)&#8221; state or all data between the largest acknowledged Min Stream Offset and the current Min Stream Offset has been acknowledged.  Note that the later condition includes the trivial case of receiving an acknowledgment for the latest MIN_STREAM_DATA frame.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#iana" id="iana">IANA Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This document has no actions for IANA.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#security" id="security">Security Considerations</a>
</h1>
<p id="rfc.section.9.p.1">This document has no new security considerations.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a>
</h1>
<p id="rfc.section.10.p.1">Many thanks to Mike Bishop and Ian Swett for their feedback on flow control issues.  Kudos to the QUIC working group for a mountain of feedback on this draft and for diligently plowing through hard problems, making thousands of big and small decisions, to make the Internet better for everyone.</p>
<h1 id="rfc.references">
<a href="#rfc.references">11.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-quic-applicability">[I-D.ietf-quic-applicability]</b></td>
<td class="top">
<a>Kuehlewind, M.</a> and <a>B. Trammell</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-applicability-01">Applicability of the QUIC Transport Protocol</a>", Internet-Draft draft-ietf-quic-applicability-01, October 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-quic-recovery">[I-D.ietf-quic-recovery]</b></td>
<td class="top">
<a>Iyengar, J.</a> and <a>I. Swett</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-recovery-08">QUIC Loss Detection and Congestion Control</a>", Internet-Draft draft-ietf-quic-recovery-08, December 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-quic-transport">[I-D.ietf-quic-transport]</b></td>
<td class="top">
<a>Iyengar, J.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-08">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport-08, December 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Igor Lubashev</span> 
	  <span class="n hidden">
		<span class="family-name">Lubashev</span>
	  </span>
	</span>
	<span class="org vcardline">Akamai Technologies</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:igorlord@alum.mit.edu">igorlord@alum.mit.edu</a></span>

  </address>
</div>

</body>
</html>

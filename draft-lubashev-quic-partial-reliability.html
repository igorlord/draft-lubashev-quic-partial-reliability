<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Partially Reliable Streams for QUIC</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 525px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 15px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
    overscroll-behavior: contain;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 25px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Notational Conventions">
<link href="#rfc.section.2" rel="Chapter" title="2 Introduction">
<link href="#rfc.section.3" rel="Chapter" title="3 Partially Reliabile Streams">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Min Stream Offset">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 MIN_STREAM_DATA Frame">
<link href="#rfc.section.4" rel="Chapter" title="4 Effect of MIN_STREAM_DATA on Flow Control">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Sender Flow Control">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Receiver Flow Control">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 ACK of MIN_STREAM_DATA">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 ACK of MIN_STREAM_DATA and MAX_DATA">
<link href="#rfc.section.5" rel="Chapter" title="5 Sender Interface and Behavior">
<link href="#rfc.section.6" rel="Chapter" title="6 Receiver Interface and Behavior">
<link href="#rfc.section.7" rel="Chapter" title="7 Retransmission of MIN_STREAM_DATA">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations">
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgments">
<link href="#rfc.references" rel="Chapter" title="11 Normative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.8.2 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Lubashev, I." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-lubashev-quic-partial-reliability-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-1-2" />
  <meta name="dct.abstract" content="This memo introduces a MIN_STREAM_DATA frame to enable partial reliability for QUIC streams.  The MIN_STREAM_DATA frame allows a sender to give up on retransmitting older parts of a stream and to notify the receiver about this decision. The content of this draft is intended for merging into QUIC transport, recovery, and applicability drafts." />
  <meta name="description" content="This memo introduces a MIN_STREAM_DATA frame to enable partial reliability for QUIC streams.  The MIN_STREAM_DATA frame allows a sender to give up on retransmitting older parts of a stream and to notify the receiver about this decision. The content of this draft is intended for merging into QUIC transport, recovery, and applicability drafts." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">QUIC</td>
<td class="right">I. Lubashev</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Akamai Technologies</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">January 2, 2018</td>
</tr>
<tr>
<td class="left">Expires: July 6, 2018</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Partially Reliable Streams for QUIC<br />
  <span class="filename">draft-lubashev-quic-partial-reliability-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This memo introduces a MIN_STREAM_DATA frame to enable partial reliability for QUIC streams.  The MIN_STREAM_DATA frame allows a sender to give up on retransmitting older parts of a stream and to notify the receiver about this decision. The content of this draft is intended for merging into QUIC transport, recovery, and applicability drafts.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on July 6, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Notational Conventions</a>
</li>
<li>2.   <a href="#rfc.section.2">Introduction</a>
</li>
<li>3.   <a href="#rfc.section.3">Partially Reliabile Streams</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Min Stream Offset</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">MIN_STREAM_DATA Frame</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Effect of MIN_STREAM_DATA on Flow Control</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Sender Flow Control</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Receiver Flow Control</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">ACK of MIN_STREAM_DATA</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">ACK of MIN_STREAM_DATA and MAX_DATA</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Sender Interface and Behavior</a>
</li>
<li>6.   <a href="#rfc.section.6">Receiver Interface and Behavior</a>
</li>
<li>7.   <a href="#rfc.section.7">Retransmission of MIN_STREAM_DATA</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a>
</li>
<li>10.   <a href="#rfc.section.10">Acknowledgments</a>
</li>
<li>11.   <a href="#rfc.references">Normative References</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#conventions" id="conventions">Notational Conventions</a>
</h1>
<p id="rfc.section.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.2.p.1">Some applications, especially applications with real-time requirements, need a partially reliable transport.  These applications typically communicate data in application-specific messages that are serialized over QUIC streams.  Applications desire partially reliable transport, when their messages expire and lose their usefulness due to later events (time passing, newer messages, etc).</p>
<p id="rfc.section.2.p.2">The content of this draft is intended for <a href="#I-D.ietf-quic-transport" class="xref">[I-D.ietf-quic-transport]</a>, <a href="#I-D.ietf-quic-recovery" class="xref">[I-D.ietf-quic-recovery]</a> and, <a href="#I-D.ietf-quic-applicability" class="xref">[I-D.ietf-quic-applicability]</a>.</p>
<p id="rfc.section.2.p.3">The key to partial reliablity is notifying the peer about data that will not be retransmitted and managing flow control for the connection.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#partially-reliabile-streams" id="partially-reliabile-streams">Partially Reliabile Streams</a>
</h1>
<p id="rfc.section.3.p.1">It is possible to provide partial reliablity without any changes to QUIC transport by using QUIC streams, encoding one message per QUIC stream.  When the message expires, the sender can reset the stream, causing RST_STREAM frame to be transmitted, unless all data in the stream has already been fully acknowledged.  The problem with this approach is that messages transmitted by the application typically belong to a message stream, and applications may need to support multiple concurrent message streams.  Hence, a message-per-stream approach requires each message to contain an extra header portion to associate the message with a logical application stream.  In case of short messages, this approach introduces a significant overhead due to STREAM frames and message headers. It also places the burden on the application to reorder data arriving on multiple QUIC streams.  Furthermore, splitting each application stream into multiple QUIC streams renders QUIC per-stream flow control ineffective and requires an application to build its own.</p>
<p id="rfc.section.3.p.2">An alternative is the proposed single-stream mechanism that keeps messages arriving in order on a single stream.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#min-stream-offset" id="min-stream-offset">Min Stream Offset</a>
</h1>
<p id="rfc.section.3.1.p.1">This proposal introduces a new QUIC stream variable &#8220;Min Stream Offset&#8221; that indicates the smallest retransmittable data offset.  The receiver SHOULD NOT wait for any data at offsets smaller than Min Stream Offset to be retransmitted by the sender.  Initially, Min Stream Offset is 0 for all streams.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#min_stream_data" id="min_stream_data">MIN_STREAM_DATA Frame</a>
</h1>
<p id="rfc.section.3.2.p.1">The MIN_STREAM_DATA frame (types 0x?? (type) and 0x?? (type+1)) is used in flow control to inform the peer of the minimum (re-)transmittable data offset on a stream.  If the least significant bit is set, Unsent Bytes field is present in the frame.</p>
<p id="rfc.section.3.2.p.2">The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sent Data (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Unsent Bytes (i)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.3.2.p.3">The fields in the MIN_STREAM_DATA frame are as follows:</p>
<p></p>

<dl>
<dt>Stream ID:</dt>
<dd style="margin-left: 8">The stream ID of the stream that is affected encoded as a variable-length integer.</dd>
<dt>Sent Data:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the number of data octets written to the stream (since the beginning of the stream) that have expired and will not be retransmitted.</dd>
<dt>Unsent Bytes:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the number of data octets past Sent Data that have expired but have never been sent and will not be transmitted.  If Unsent Bytes field is absent, it is presumed to be 0.</dd>
</dl>
<p id="rfc.section.3.2.p.5">Since Stream 0 MUST be reliable, Stream ID MUST NOT be 0.  If Unsent Bytes field is present in the frame, it MUST NOT be 0 (reserved for the future use).</p>
<p id="rfc.section.3.2.p.6">If Unsent Bytes field is present in the frame, it implies that all data previously sent to the receiver on the stream has expired.  Hence, Sent Data is implicitly the Largest Sent Data on the stream.</p>
<p id="rfc.section.3.2.p.7">Min Stream Offset (<a href="#min-stream-offset" class="xref">Section 3.1</a>) for Stream ID is determined by the formula:</p>
<pre>
  Min Stream Offset = Sent Data + Unsent Bytes
</pre>
<p id="rfc.section.3.2.p.8">The Min Stream Offset for a stream MUST NOT be reduced by the sender in a subsequent MIN_STREAM_DATA frame, but loss and reordering can cause MIN_STREAM_DATA frames to be received out of order.  MIN_STREAM_DATA frames that do not increase the stream&#8217;s Min Stream Offset MUST be ignored.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#flow-control" id="flow-control">Effect of MIN_STREAM_DATA on Flow Control</a>
</h1>
<p id="rfc.section.4.p.1">Specifying Unsent Bytes separately from Send Data in MIN_STREAM_DATA frame is done to avoid using its stream and connection flow control credits to notify the other endpoint of bytes that have never been and will never be transmitted.  Hence, a sender that desires to expire a large number of bytes that have never been transmitted can do so in a single frame without closing down the connection flow control window, affecting other streams, and without a risk of exceeding its stream or connection flow control credits.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#flow-control-sender" id="flow-control-sender">Sender Flow Control</a>
</h1>
<p id="rfc.section.4.1.p.1">When an ACK frame is received for a packet containing a MIN_STREAM_OFFSET frame, and the current Largest Data Sent of the stream is smaller than Min Stream Offset of the acknowledged MIN_STREAM_OFFSET frame, the Largest Data Sent is advanced to the Min Stream Offset.  Note that this can only happen, when Unsent Bytes is non-zero in the MIN_STREAM_OFFSET frame.</p>
<p id="rfc.section.4.1.p.2">If the Largest Data Sent for at least one stream was advanced due to the receipt of a packet with an ACK frame, and, after processing that entire packet, the sum of the Largest Data Sent on all streams - including streams in terminal states but excluding stream 0 - exceeds MAX_DATA, the sender MUST terminate a connection with a QUIC_FLOW_CONTROL_SENT_TOO_MUCH_DATA error.</p>
<p id="rfc.section.4.1.p.3">It is possible that the Largest Data Sent for at least one stream will be advanced past MAX_STREAM_DATA for that stream.  In that case, no more data octets can be sent on the stream until a MAX_STREAM_DATA frame advancing the maximum offset is received.  Note that this does not prohibit using the Largest Data Sent beyond MAX_STREAM_DATA in an RST_STREAM frame, a MIN_STREAM_DATA frame, or a STREAM frame with no data and FIN bit set.</p>
<p id="rfc.section.4.1.p.4">TODO: Work on this!</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#flow-control-receiver" id="flow-control-receiver">Receiver Flow Control</a>
</h1>
<p id="rfc.section.4.2.p.1">The value of the Largest Received Offset on the stream is immediately advanced, if it is smaller than Sent Data.</p>
<p id="rfc.section.4.2.p.2">When computing window updates for MAX_STREAM_DATA and MAX_DATA frames, the receiver SHOULD use the larger of Min Stream Offset and Largest Received Offset for the stream.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#ack-min-stream-data" id="ack-min-stream-data">ACK of MIN_STREAM_DATA</a>
</h1>
<p id="rfc.section.4.3.p.1">Sending an ACK frame for a packet containing MIN_STREAM_DATA frame that advanced Min Stream Offset past Largest</p>
<p id="rfc.section.4.3.p.2">Received Offset for the stream causes Largest Received Offset to be</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#ack-max-data" id="ack-max-data">ACK of MIN_STREAM_DATA and MAX_DATA</a>
</h1>
<p id="rfc.section.4.4.p.1">FIXME START: Must ensure that connection window can only be used by the gap in the stream!</p>
<p id="rfc.section.4.4.p.2">When computing window updates for MAX_STREAM_DATA and MAX_DATA, the receiver SHOULD use the larger of &#8220;Min Stream Offset&#8221; and &#8220;the largest data offset&#8221; received for the stream.</p>
<p id="rfc.section.4.4.p.3">FIXME END</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#sender" id="sender">Sender Interface and Behavior</a>
</h1>
<p id="rfc.section.5.p.1">It is recommended that a QUIC library API provides a way for a sender to update the minimum retransmittable offset for a stream.  A typical sender would call an API function providing this functionality whenever any data previously enqueued for transmission expires, per application semantics.  The sender would keep track of the message boundaries and request expiration of data on a message boundary.</p>
<p id="rfc.section.5.p.2">If all data between the current Min Stream Offset and the new Min Stream Offset has been acknowledged, no action is performed by the sender&#8217;s QUIC implementation.  Otherwise, if there is unacknowledged data, a MIN_STREAM_DATA frame is transmitted.</p>
<p id="rfc.section.5.p.3">An application may decide to conditionally expire messages based on the delivery status of prior messages.  For example, an application may wish to ensure that its large messages are delivered at least at a given minimum rate before expiring a partially-delivered message just because their is a newer message to deliver.  That is, if the rate of data the application wishes to write exceeds the network&#8217;s throughput, the application may want to ensure that at least some messages are delivered in their entirety.  To support this use case, it is recommended that a QUIC library API provides a way for the sender to minitor the smallest unacknowledged stream offset greater than Min Stream Offset (<a href="#min-stream-offset" class="xref">Section 3.1</a>).</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#receiver" id="receiver">Receiver Interface and Behavior</a>
</h1>
<p id="rfc.section.6.p.1">The receiver SHOULD assume that none of the data up to Min Stream Offset (<a href="#min-stream-offset" class="xref">Section 3.1</a>) will be retransmitted.</p>
<p id="rfc.section.6.p.2">It is recommended that a QUIC library API provides a way for a receiver to obtain the length of a gap corresponding to the expired data in addition to data octets that follow the gap.</p>
<p id="rfc.section.6.p.3">A receiver MAY discard any stream data received for an offset smaller than Min Stream Offset.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#retransmission" id="retransmission">Retransmission of MIN_STREAM_DATA</a>
</h1>
<p id="rfc.section.7.p.1">The most recent MIN_STREAM_DATA frame for a stream MUST be retransmitted until the sender is certain that the receiver is not expecting retransmission of any expired data.  I.e. the frame MUST be retransmitted until either the stream enters &#8220;half-closed (local)&#8221; state or all data between the largest acknowledged Min Stream Offset and the current Min Stream Offset has been acknowledged.  Note that the later condition includes the trivial case of receiving an acknowledgment for the latest MIN_STREAM_DATA frame.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#iana" id="iana">IANA Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This document has no actions for IANA.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#security" id="security">Security Considerations</a>
</h1>
<p id="rfc.section.9.p.1">This document has no new security considerations.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a>
</h1>
<p id="rfc.section.10.p.1">Many thanks to Mike Bishop for his feedback on flow control issues and proofreading the first draft.  Kudos to the QUIC working group for a mountain of feedback on this draft and for diligently plowing through hard problems and making thousands of big and small decisions to make the Internet better for everyone.</p>
<h1 id="rfc.references">
<a href="#rfc.references">11.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-quic-applicability">[I-D.ietf-quic-applicability]</b></td>
<td class="top">
<a>Kuehlewind, M.</a> and <a>B. Trammell</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-applicability-01">Applicability of the QUIC Transport Protocol</a>", Internet-Draft draft-ietf-quic-applicability-01, October 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-quic-recovery">[I-D.ietf-quic-recovery]</b></td>
<td class="top">
<a>Iyengar, J.</a> and <a>I. Swett</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-recovery-08">QUIC Loss Detection and Congestion Control</a>", Internet-Draft draft-ietf-quic-recovery-08, December 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-quic-transport">[I-D.ietf-quic-transport]</b></td>
<td class="top">
<a>Iyengar, J.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-08">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport-08, December 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Igor Lubashev</span> 
	  <span class="n hidden">
		<span class="family-name">Lubashev</span>
	  </span>
	</span>
	<span class="org vcardline">Akamai Technologies</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:igorlord@alum.mit.edu">igorlord@alum.mit.edu</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/igorlord/draft-lubashev-quic-partial-reliability">Fork me on GitHub</a></div></div>
</body>
</html>
